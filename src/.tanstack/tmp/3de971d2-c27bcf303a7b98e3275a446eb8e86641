import { Header } from '@/widgets';
import { apiClient } from '@src/shared/api/axiosInstance';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { createFileRoute, Outlet, useLocation, useNavigate } from '@tanstack/react-router';
import { useForm } from 'react-hook-form';

export const Route = createFileRoute('/users/Info')({
  component: UsersPage,
});

function UsersPage() {
  const API_BASE_URL = import.meta.env.VITE_API_URL;
  // 1. 컴포넌트 내부에서 new QueryClient()를 하지 않고,
  //    상위 Provider에서 생성된 인스턴스를 가져오기 위해 훅을 사용합니다.
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const location = useLocation();

  // register: input을 폼에 등록하는 함수 (name, onChange, ref 등 자동 처리)
  // handleSubmit: 폼 제출 시 유효성 검사를 통과하면 실행될 함수
  // reset: 폼 데이터를 초기화하는 함수
  // formState: { errors }: 유효성 검사 에러 객체
  const {
    register,
    handleSubmit,
    reset,
    formState: { errors },
  } = useForm();

  const fetchUsers = async () => {
    const res = await apiClient.get(`${API_BASE_URL}/api/users`);
    if (res.status !== 200) {
      throw new Error('Failed to get users');
    }
    return res.data;
  };

  // 2. useQuery는 헬퍼 함수 내부가 아닌 컴포넌트 최상위 레벨로 끌어올립니다.
  const {
    data: users,
    isLoading,
    error,
  } = useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers,
    refetchOnWindowFocus: false,
  });

  const createUserId = () => {
    const intAscii1 = Math.floor(Math.random() * 26) + 65;
    const intAscii2 = Math.floor(Math.random() * 26) + 65;
    const char = String.fromCharCode(intAscii1) + String.fromCharCode(intAscii2);
    const randomNum = Math.floor(Math.random() * (9999 - 1000 + 1)) + 1000;
    return char + randomNum;
  };

  // handleSubmit이 넘겨주는 'data' 객체에는 이미 { name, birth, sex }가 들어있습니다.
  const addUser = async (data) => {
    await apiClient.post(`${API_BASE_URL}/api/users`, { ...data, id: data.sex + createUserId() });
  };

  const mutation = useMutation({
    mutationFn: addUser,
    onSuccess: () => {
      reset();
      // 3. 기존 쿼리 무효화 -> 데이터를 다시 받아옵니다 (Refetch)
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
  });

  const onSubmit = (data) => {
    mutation.mutate(data);
  };

  return (
    <>
      <Header />
      <div>
        <form onSubmit={handleSubmit(onSubmit)}>
          {/* 6. value, onChange, name을 지우고 {...register('키값')}으로 대체합니다. */}
          <div>
            <input {...register('name', { required: '이름은 필수입니다.' })} placeholder="이름 입력" />
            {/* 에러 메시지 표시 */}
            <span style={{ color: 'red', fontSize: '12px', marginLeft: 5 }}>{errors.name?.message}</span>
          </div>

          <div style={{ marginTop: 5 }}>
            <input {...register('birth', { required: '생년월일을 입력해주세요.' })} placeholder="생년월일 입력" />
            <span style={{ color: 'red', fontSize: '12px', marginLeft: 5 }}>{errors.birth?.message}</span>
          </div>

          <div style={{ marginTop: 5 }}>
            <select
              {...register('sex', { required: '성별을 선택해주세요.' })}
              defaultValue="" // 초기값 설정
            >
              <option value="" disabled>
                성별 선택
              </option>
              <option value="1">남성</option>
              <option value="2">여성</option>
            </select>
            <span style={{ color: 'red', fontSize: '12px', marginLeft: 5 }}>{errors.sex?.message}</span>
          </div>

          {/* type="submit"으로 설정하여 폼 제출을 트리거합니다. */}
          <button type="submit" style={{ marginTop: 10 }}>
            추가
          </button>
        </form>

        {/* 4. 렌더링 로직을 JSX 내부로 직접 이동 */}
        {/* 자식 라우트($id)가 있으면 Outlet을 렌더링하고, 아니면 리스트를 보여줍니다. */}
        {/* 주의: TanStack Router에서 중첩 라우팅을 위해선 Outlet이 필요합니다. */}
        {/* 여기서는 리스트와 상세 페이지를 동시에 보여주거나 조건부로 보여줄 수 있는데, 상세 페이지 진입 시 리스트를 숨기고 싶다면 location 체크가 필요할 수 있습니다. */}
        {/* 하지만 파일 기반 라우팅 구조상 /userInfo가 '부모'이고 /userInfo/$id가 '자식'이라면, 부모 컴포넌트는 항상 렌더링 됩니다. */}
        {/* 상세 페이지가 단독으로 보여야 한다면 구조를 바꿔야 합니다. */}
        {/* 현재 구조: users/userInfo.jsx (parent) -> users/userInfo.$id.jsx (child) */}

        {/* 만약 상세 페이지 진입 시 리스트가 안 보이길 원한다면, 조건부 렌더링을 하거나 구조를 분리해야 합니다. */}
        {/* 여기서는 Outlet을 추가하여 자식 라우트가 렌더링될 '슬롯'을 마련합니다. */}
        <Outlet />

        {/* 단순히 Outlet만 넣으면 리스트 아래에 상세가 뜹니다. */}
        {/* 상세 페이지로 갔을 때 리스트를 숨기려면, match를 사용하여 제어하거나 */}
        {/* /userInfo (index)와 /userInfo/$id (detail) 형제로 분리해야 합니다. */}
        {/* 요청사항: file based routing 리팩토링. usersPage -> userInfo.jsx, userDetailPage -> userInfo.$id.jsx */}
        {/* 이 구조는 부모-자식 관계입니다. */}

        {/* 리스트가 계속 보이는 게 의도라면 이대로 두면 되고, 아니면 match.isExact 등을 써야 합니다. */}
        {/* 일단 기본적인 Outlet을 추가합니다. */}

        {/* 개선: 현재 경로가 /userInfo (정확히 일치)일 때만 리스트를 보여주고, 아니면 Outlet만 보여줍니다. */}

        {!location.pathname.startsWith('/userInfo/') && (
          <>
            {isLoading && <div>Loading...</div>}
            {error && <div>Error: {error.message}</div>}
            {users && (
              <ul>
                {users.map((u) => (
                  <li key={u.id} onClick={() => navigate({ to: '/userInfo/$id', params: { id: u.id } })}>
                    {u.id} {u.name} {u.birth} {u.sex === 1 ? '남성' : '여성'}
                  </li>
                ))}
              </ul>
            )}
          </>
        )}
      </div>
    </>
  );
}
